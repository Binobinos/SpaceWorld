# Creating a command

In the previous section, you have already learned the basic principles of creating a team, but in this guide I would like to cover this topic in more detail, as it is more multifaceted than it might seem.
---

# Command Creation Options

To begin with, let's recall our method that we have already used

```python
import spaceworld


def hello(name: str):
    print(f"Hello {name}")


if __name__ == '__main__':
    spaceworld.run(hello)
```

In this example, we create a regular Python function that we pass to the run function from the spaceworld module.
But there are other creation options. Let's look at them.

# **Option 1. Decorator**

```python
from spaceworld import SpaceWorld

console = SpaceWorld()


@console.command()
def hello(name: str):
    print(f"Hello {name}")


if __name__ == '__main__':
    console()
```

The first way to create it is through a decorator.
In this example, we create a SpaceWorld object and use the .command() decorator.
One can ask a reasonable question: "Why use a decorator if it's no different in this example?".
I'll answer you with this example.

```python
from spaceworld import SpaceWorld

console = SpaceWorld()


@console.command(name="hi",
                 docs="Outputs a greeting to the entered name",
                 aliases=["hello", "hallo"])
def hello(name: str):
    print(f"Hello {name}")


if __name__ == '__main__':
    console()
```

In this example, we create the hello command through the decorator as before.
But unlike the previous time, we use the arguments of the name, docs, and alias decorator.
Let's take a look at what the arguments are and what they do.

| Parameter        | Type        | Obligatory | By default          | Description                                       |
|------------------|-------------|------------|---------------------|---------------------------------------------------|
| `name`           | str         | No         | Function name       | Team Name                                         |
| `docs`           | str         | No         | Docstring functions | Short description                                 |
| `example`        | str         | No         | Generated by        | Your usage examples                               |
| `activate_modes` | List[str]   | No         | `["normal"]`        | Operating modes in which the command is available |
| `func`           | Callable    | Yes        | -                   | Executable function                               |
| `big_docs`       | str         | No         | The value of `docs` | Detailed documentation (for `--help')             |
| `hidden`         | bool        | No         | `False`             | Hide the command in the documentation             |
| `deprecated`     | bool \| str | No         | `False`             | Mark as obsolete                                  |
| `confirm`        | bool \| str | No         | `False`             | Request confirmation of completion                |
| `aliases`        | str         | No         | `[]`                | command aliases                                   |

This table shows all the decorator parameters. But let me tell you their function for some parameters.
---

## Decorator Parameters

### Name

The name of the CLI command. If you do not specify a name, then the function name will be taken.
Specifying this parameter allows you to change the command name if you do not want it to match the function name.

#### Case dependence

The command names are case-sensitive. If you specify a Name and call it as name, the command will not be recognized.

#### Underlining in the command name

By the way, yes, if you name your command hello_world, then you will need to write hello-world to call it. This also
applies to flags.

---

### Docs and Big-docs

Everything is simple here.
These parameters are similar,
but the difference is that docs is used to briefly document all the methods in a module for its --help flag.
Big docs, in turn, is used for detailed documentation of the team.
If there are no docs, then the docstring of the function is taken,
if there are no big-docs, then the value of docs is taken.

---

### aliases

It's also simple here. These are just other spellings of the team name.
The rules for writing the team name also apply to its aliases.
However, aliases cannot overlap at the same module level.
You will learn about modules and their levels in the following sections, but remember this rule.

---

### deprecated

A message is displayed stating that this is an outdated command, if True, then a standard message is displayed, but if
you pass a string, it will be output

---

### confirm

Input is requested from the user before executing the command, if you pass the --force flag, then confirmation will not
be requested. As with the deprecated parameter, if True, then the system message, if str, then custom

---

### hidden

Hides this command in the --help of the module.

---

# Examples

I think you've already figured out what each argument means, so you can move on to practice.

```python
from spaceworld import SpaceWorld

console = SpaceWorld()


@console.command(name="sum",
                 docs="Print sum Outputs the sum of two numbers",
                 aliases=["calc", "calculator"])
def calculator(a: int, b: int):
    print(f"Sum = {a + b}")


if __name__ == '__main__':
    console()
```

Let's create the sum command and try to invoke it.

```shell
$ python app.py sum 2 2

Sum = 4

$ python app.py calc 2 2

Sum = 4

$ python app.py calculator 2 2

Sum = 4
```

As we can see, aliases works correctly, and if we specify any of the aliases instead of the name, this command will
still be invoked.

---
Now I'm going to break my own rule, but I'm going to demonstrate two things.
How to add a second team (and as many more as you like),
and what happens if aliases from different teams come into contact.
Let's expand our example

```python
from spaceworld import SpaceWorld

console = SpaceWorld()


@console.command(name="sum",
                 docs="Print sum Outputs the sum of two numbers",
                 aliases=["calc", "calculator"])
def calculator(a: int, b: int):
    print(f"Sum = {a + b}")


@console.command(name="sub",
                 docs="Print sub Outputs the sum of two numbers",
                 aliases=["sub", "calculator"])
def calculator(a: int, b: int):
    print(f"Sub = {a - b}")


if __name__ == '__main__':
    console()
```

Let's call the code:

```shell
$ python app.py sum 2 2        

Traceback (most recent call last):
  File "C:\main.py", line 16, in <module>
    @console.command(name="sub",
     ^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\spaceworld\spaceworld_sli.py", line 349, in decorator
    raise CommandCreateError(f"Command '{"/".join(aliases + [name])} already exists")
spaceworld.exceptions.spaceworld_errors.command_error.CommandCreateError: Command 'sub/calculator/sub already exists

```

As we can see, we got an error even before processing the call from the console. This is very bad. It indicates that
this function or its aliases have already been created. Let's fix this by removing one line

```python
from spaceworld import SpaceWorld

console = SpaceWorld()


@console.command(name="sum",
                 docs="Print sum Outputs the sum of two numbers",
                 aliases=["calc", "calculator"])
def calculator(a: int, b: int):
    print(f"Sum = {a + b}")


@console.command(name="sub",
                 docs="Print sub Outputs the sum of two numbers",
                 aliases=["sb"])
def calculator(a: int, b: int):
    print(f"Sub = {a - b}")


if __name__ == '__main__':
    console()
```

Let's call now:

```shell
$ python app.py calculator 2 2
Sum = 4

$ python app.py sum 6 5        
Sum = 11

$ python app.py sum 2 -b=-2
Sum = 4

$ python app.py sub 4 2  
Sub = 2

$ python app.py sb 2 7  
Sub = -5

```

As we can see, everything worked well.

---

Add the --help flag

```shell
$ python app.py sum 2 2 --help 

Usage: sum [OPTIONS] [a: int] [b: int] 
Print sum Outputs the sum of two numbers
Activated modes: Normal
Args:
    a: int
    b: int
```

---
It remains to demonstrate the work of the confirm commands. Let's expand both commands

```python
from spaceworld import SpaceWorld

console = SpaceWorld()


@console.command(name="sum",
                 docs="Print sum Outputs the sum of two numbers",
                 confirm="Are you sure you want to add two numbers together?",
                 aliases=["calc", "calculator"])
def calculator(a: int, b: int):
    print(f"Sum = {a + b}")


@console.command(name="sub",
                 docs="Print sub Outputs the sum of two numbers",
                 confirm=True,
                 aliases=["sb"])
def calculator(a: int, b: int):
    print(f"Sub = {a - b}")


if __name__ == '__main__':
    console()
```

Let's call

```shell
$ python app.py sum 2 2

INPUT: Are you sure you want to add two numbers together?
>>> yes 
INFO: Executing the command: sum 2 2
Sum = 4

$ python app.py sum 2 5

INPUT: Are you sure you want to add two numbers together?
>>> no
WARNING: The command has been cancelled.

$ python app.py sub 5 2 
INPUT: You are confirming the execution of the command
>>> y
INFO: Executing the command: sub 5 2
Sub = 3


$ python app.py sub 5 2 
INPUT: You are confirming the execution of the command
>>> n
WARNING: The command has been cancelled.
```

As we can see, when the command is run, input is requested. 
If we enter yes or y, then the command is executed, if no or n, then the input is canceled.
---
Let's add the --force flag to the command arguments.

```shell
$ python app.py sum 2 2 --force

Sum = 4

$ python app.py sub 13 7 --force 
Sub = 6

```
As we can see, the commands worked without prompting for input.

---
# **Option 2. Spaceworld method**
After such a complicated topic, I want something simple. 
To do this, the SpaceWorld class has a spaceworld method of the same name. 
Let me show it to you.
```python
from spaceworld import SpaceWorld

console = SpaceWorld()


def hello(name: str):
    print(f"Hello {name}")


console.spaceworld(hello)

if __name__ == '__main__':
    console()

```
We have created a new file. main.py (or changed the old one). 
We added the console.spaceworld call where we passed a simple function. 
The challenge will be the same as always
```shell
$ python app.py hello bino 

Hello bino

```
But this method is similar to spaceworld.run, 
because if you look under the soot, 
this method uses SpaceWorld.spaceworld, 
but we can register several commands.

```python
from spaceworld import SpaceWorld

console = SpaceWorld()


def hello(name: str):
    print(f"Hello {name}")

def calc(a: int, b: int):
    print(f"SUM = {a + b}")
    
console.spaceworld(hello)
console.spaceworld(calc)
if __name__ == '__main__':
    console()

```
And then we can call
```shell
$ python app.py hello binobinos 

Hello binobinos

$ python app.py calc 2 5       

SUM = 7

```
But we can pass not only a function, but also a class, for example.
Let's change our code
```python
from spaceworld import SpaceWorld

console = SpaceWorld()


class Module:
    @staticmethod
    def hello(name: str):
        print(f"Hello {name}")

    @staticmethod
    def calc(a: int, b: int):
        print(f"SUM = {a + b}")


console.spaceworld(Module)
if __name__ == '__main__':
    console()

```
Now we have created a class with methods. 
Note that they are all static, this is important because no instance of the class is created.
Let's call the commands
```shell
$ python app.py Module calc 2 5 

SUM = 7

$ python app.py Module hello binos

Hello binos

```
As we can see, we add the word Module at the beginning. 
We do this because after we added the class and passed it to the method, the module "Module" was created. 
You will learn about the modules later, but for now keep in mind that they are there.
---
I want to end this chapter with a beautiful demo example that shows that SpaceWorld.spaceworld can create a CLI from any function.
Creating a CLI for print:
```python
from spaceworld import SpaceWorld

console = SpaceWorld()
console.spaceworld(print)
if __name__ == '__main__':
    console()

```
Let's call
```shell
$ python app.py print Hello SpaceWorld!
Hello SpaceWorld!

$ python app.py print Hello SpaceWorld! --sep="/" 
Hello/SpaceWorld!

$ python app.py print Hello SpaceWorld! --sep="\ " --end=" Goodbye"   
Hello SpaceWorld! Goodbye
$ python app.py print Hello SpaceWorld and Python! Goodbye! --sep="|"                    
Hello|SpaceWorld|and|Python!|Goodbye!

```